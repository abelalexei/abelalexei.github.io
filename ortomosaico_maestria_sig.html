<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visor de Ortomosaico - Práctica SIG</title>
    <!-- Tailwind CSS para un diseño moderno y responsivo --><script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* Estilo para el cuerpo y la fuente principal */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Estilo para el canvas para evitar que se seleccione el texto al arrastrar */
        canvas {
            touch-action: none;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 antialiased">

    <div class="container mx-auto px-4 py-8 md:py-12">
        <header class="mb-8 flex flex-col md:flex-row justify-center items-center text-center md:space-x-8">
            <!-- Logo de la UES con ruta absoluta --><img src="https://raw.githubusercontent.com/abelalexei/abelalexei.github.io/main/images/logo_ues.png" alt="Logo UES" class="h-24 md:h-28 mb-4 md:mb-0 flex-shrink-0">
            
            <!-- Títulos --><div class="max-w-2xl">
                <h1 class="text-3xl md:text-4xl font-bold text-cyan-400">Ortomosaico de la práctica del curso SIG</h1>
                <p class="text-lg md:text-xl text-gray-400 mt-2">Maestría en Gestión Integral del Agua</p>
                <p class="text-md md:text-lg text-gray-300 mt-2">Escuela de Posgrado y Educación Continua, Facultad de Ciencias Agronómicas, Universidad de El Salvador</p>
            </div>

            <!-- Logo Agronomía con ruta absoluta --><img src="https://raw.githubusercontent.com/abelalexei/abelalexei.github.io/main/images/logo_agronomia.png" alt="Logo Agronomía" class="h-24 md:h-28 mt-4 md:mt-0 flex-shrink-0">
        </header>

        <main class="flex flex-col items-center">
            <!-- Contenedor del visor de la imagen --><div id="viewer-container" class="w-full max-w-6xl bg-gray-800 rounded-lg shadow-2xl overflow-hidden border-2 border-gray-700">
                <div id="loader" class="flex justify-center items-center h-96 text-gray-400">
                    <svg class="animate-spin -ml-1 mr-3 h-8 w-8 text-cyan-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    <span>Cargando ortomosaico...</span>
                </div>
                <canvas id="tiff-canvas" class="hidden w-full h-auto aspect-video"></canvas>
            </div>
            
            <!-- Controles -->
            <div class="mt-6 w-full max-w-6xl flex flex-col gap-3">
                <div class="flex flex-col sm:flex-row items-center justify-between gap-3">
                    <div class="flex items-center gap-2">
                        <button id="zoom-out" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-3 rounded-md shadow">
                            −
                        </button>
                        <button id="zoom-in" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-3 rounded-md shadow">
                            +
                        </button>
                        <button id="zoom-100" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold py-2 px-3 rounded-md shadow">
                            100%
                        </button>
                        <button id="reset-button" class="bg-cyan-600 hover:bg-cyan-500 text-white font-semibold py-2 px-3 rounded-md shadow">
                            Ajustar
                        </button>
                    </div>
                    <div class="flex items-center gap-3 w-full sm:w-auto">
                        <input id="zoom-slider" type="range" min="0.05" max="4" step="0.01" value="1" class="w-full sm:w-64">
                        <span id="zoom-label" class="text-sm text-gray-400 w-16 text-right">100%</span>
                    </div>
                </div>
                <div class="text-sm text-gray-500 text-center sm:text-left">
                    <p>Usa los botones o la rueda del ratón/gesto de pellizcar para hacer zoom.</p>
                    <p>Haz clic y arrastra para mover la imagen.</p>
                </div>
            </div>
        </main>

        <footer class="text-center text-gray-600 mt-12">
            <p>Landing Page creada con fines demostrativos.</p>
        </footer>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- CONFIGURACIÓN ---
            // Nueva ruta proporcionada por el usuario (Imgur - URL de página), necesitamos la URL directa de la imagen
            const imgurPageUrl = 'https://imgur.com/jyZCdWl';
            const imgurId = 'jyZCdWl';
            // Candidatos directos en Imgur (i.imgur.com) con distintas extensiones posibles
            const imgurCandidates = [
                `https://i.imgur.com/${imgurId}.jpg`,
                `https://i.imgur.com/${imgurId}.png`,
                `https://i.imgur.com/${imgurId}.jpeg`
            ];
            // Fallback: imagen RAW de GitHub usada anteriormente, por si Imgur falla
            const githubRawUrl = 'https://raw.githubusercontent.com/abelalexei/abelalexei.github.io/main/images/ortomosaico_maestria_sig_res.jpg';

            // --- ELEMENTOS DEL DOM ---
            const canvas = document.getElementById('tiff-canvas');
            const ctx = canvas.getContext('2d');
            const loader = document.getElementById('loader');
            const resetButton = document.getElementById('reset-button');
            const viewerContainer = document.getElementById('viewer-container');
            // Nuevos controles de zoom
            const zoomInBtn = document.getElementById('zoom-in');
            const zoomOutBtn = document.getElementById('zoom-out');
            const zoom100Btn = document.getElementById('zoom-100');
            const zoomSlider = document.getElementById('zoom-slider');
            const zoomLabel = document.getElementById('zoom-label');

            // --- ESTADO DEL VISOR ---
            let img = null; // Almacenará los datos de la imagen decodificada
            let transform = {
                scale: 1,
                offsetX: 0,
                offsetY: 0,
            };
            let isDragging = false;
            let lastPos = { x: 0, y: 0 };
            let initialPinchDistance = null;

            // --- CARGA Y RENDERIZADO DE LA IMAGEN ---
            // Prueba de carga de imagen (sin CORS HEAD), confiable bajo file://
            function canLoadImage(url, timeout = 10000) {
                return new Promise((resolve) => {
                    const test = new Image();
                    test.crossOrigin = 'Anonymous';
                    let done = false;
                    const t = setTimeout(() => { if (!done) { done = true; resolve(false); } }, timeout);
                    test.onload = () => { if (!done) { done = true; clearTimeout(t); resolve(true); } };
                    test.onerror = () => { if (!done) { done = true; clearTimeout(t); resolve(false); } };
                    test.src = url;
                });
            }

            async function resolveImageUrl() {
                // 1) Intentar Imgur directo con diferentes extensiones
                for (const u of imgurCandidates) {
                    if (await canLoadImage(u)) return u;
                }
                // 2) Fallback a RAW de GitHub (anterior)
                if (await canLoadImage(githubRawUrl)) return githubRawUrl;
                return null;
            }

            async function loadImage() {
                loader.innerHTML = '<span>Buscando imagen del ortomosaico...</span>';
                const finalUrl = await resolveImageUrl();
                if (!finalUrl) {
                    loader.innerHTML = `<span class="text-red-400">Error: No se pudo resolver ninguna URL válida de imagen (Imgur/GitHub). Verifica la ruta.</span>`;
                    return;
                }

                const image = new Image();
                image.crossOrigin = 'Anonymous';

                image.onload = () => {
                    img = image;
                    canvas.width = img.width;
                    canvas.height = img.height;
                    loader.style.display = 'none';
                    canvas.classList.remove('hidden');
                    initialView(); // Vista inicial al 80% centrada
                };

                image.onerror = (error) => {
                    console.error('Error al cargar la imagen seleccionada:', finalUrl, error);
                    loader.innerHTML = `<span class="text-red-400">Error: No se pudo cargar la imagen desde ${finalUrl}. Revisa la URL.</span>`;
                };

                image.src = finalUrl;
            }
            
            // Dibuja la imagen en el canvas con la transformación actual
            function draw() {
                if (!img) return;
                
                // Limpiar el canvas
                ctx.save();
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Aplicar transformaciones de paneo y zoom
                ctx.translate(transform.offsetX, transform.offsetY);
                ctx.scale(transform.scale, transform.scale);
                
                // Dibujar la imagen
                ctx.drawImage(img, 0, 0);
                
                ctx.restore();
            }

            // Resetea la vista para que la imagen CUBRA el contenedor (modo 'cover')
            function resetView() {
                if (!img) return;
                
                // Calcular la escala para que la imagen CUBRA el contenedor
                const scaleX = viewerContainer.clientWidth / img.width;
                const scaleY = viewerContainer.clientHeight / img.height;
                const initialScale = Math.max(scaleX, scaleY); // 'cover'
                
                transform.scale = initialScale;
                
                // Centrar la imagen
                transform.offsetX = (viewerContainer.clientWidth - img.width * initialScale) / 2;
                transform.offsetY = (viewerContainer.clientHeight - img.height * initialScale) / 2;
                
                updateZoomUI();
                draw();
            }

            // Vista inicial: 80% del tamaño 1:1, centrada
            function initialView() {
                if (!img) return;
                
                const targetScale = 0.8; // 80% del tamaño original (1:1)
                transform.scale = targetScale;
                
                // Centrar la imagen en el visor
                transform.offsetX = (viewerContainer.clientWidth - img.width * targetScale) / 2;
                transform.offsetY = (viewerContainer.clientHeight - img.height * targetScale) / 2;
                
                updateZoomUI();
                draw();
            }

            // Utilidad para actualizar label y slider del zoom
            function updateZoomUI() {
                if (!zoomSlider || !zoomLabel) return;
                // Ajustar slider al rango si se sale
                const clamped = Math.min(Math.max(transform.scale, parseFloat(zoomSlider.min)), parseFloat(zoomSlider.max));
                zoomSlider.value = clamped.toFixed(2);
                zoomLabel.textContent = `${Math.round(clamped * 100)}%`;
            }

            // Aplica zoom centrado en un punto (cx, cy) en coordenadas de pantalla
            function applyZoom(newScale, cx, cy) {
                newScale = Math.max(parseFloat(zoomSlider.min), Math.min(parseFloat(zoomSlider.max), newScale));
                const worldX = (cx - transform.offsetX) / transform.scale;
                const worldY = (cy - transform.offsetY) / transform.scale;
                transform.offsetX = cx - worldX * newScale;
                transform.offsetY = cy - worldY * newScale;
                transform.scale = newScale;
                updateZoomUI();
                draw();
            }

            // --- MANEJADORES DE EVENTOS ---

            // Zoom con la rueda del ratón
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomIntensity = 0.1;
                const direction = e.deltaY > 0 ? -1 : 1;
                const scaleAmount = 1 + direction * zoomIntensity;

                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Coordenadas del puntero en el mundo de la imagen
                const worldX = (mouseX - transform.offsetX) / transform.scale;
                const worldY = (mouseY - transform.offsetY) / transform.scale;
                
                const newScale = Math.max(0.1, transform.scale * scaleAmount); // Limitar zoom mínimo
                applyZoom(newScale, mouseX, mouseY);
            });
            
            // Iniciar arrastre (ratón y táctil)
            function startDrag(x, y) {
                isDragging = true;
                lastPos = { x, y };
                canvas.style.cursor = 'grabbing';
            }

            // Mover (ratón y táctil)
            function drag(x, y) {
                 if (isDragging) {
                    const dx = x - lastPos.x;
                    const dy = y - lastPos.y;
                    transform.offsetX += dx;
                    transform.offsetY += dy;
                    lastPos = { x, y };
                    draw();
                }
            }
            
            // Finalizar arrastre (ratón y táctil)
            function endDrag() {
                isDragging = false;
                canvas.style.cursor = 'grab';
            }
            
            // Eventos de ratón
            canvas.addEventListener('mousedown', (e) => startDrag(e.clientX, e.clientY));
            canvas.addEventListener('mousemove', (e) => drag(e.clientX, e.clientY));
            canvas.addEventListener('mouseup', endDrag);
            canvas.addEventListener('mouseleave', endDrag);

            // Eventos táctiles
            canvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    startDrag(e.touches[0].clientX, e.touches[0].clientY);
                } else if (e.touches.length === 2) {
                    initialPinchDistance = getPinchDistance(e);
                }
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    drag(e.touches[0].clientX, e.touches[0].clientY);
                } else if (e.touches.length === 2 && initialPinchDistance) {
                    handlePinchZoom(e);
                }
            });
            
            canvas.addEventListener('touchend', (e) => {
                endDrag();
                initialPinchDistance = null;
            });
            
            // Lógica para el zoom con gesto de pellizcar
            function getPinchDistance(e) {
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                return Math.sqrt(Math.pow(t2.clientX - t1.clientX, 2) + Math.pow(t2.clientY - t1.clientY, 2));
            }

            function handlePinchZoom(e) {
                const currentPinchDistance = getPinchDistance(e);
                const scaleAmount = currentPinchDistance / initialPinchDistance;

                const rect = canvas.getBoundingClientRect();
                const t1 = e.touches[0];
                const t2 = e.touches[1];
                const centerX = (t1.clientX + t2.clientX) / 2 - rect.left;
                const centerY = (t1.clientY + t2.clientY) / 2 - rect.top;
                
                const worldX = (centerX - transform.offsetX) / transform.scale;
                const worldY = (centerY - transform.offsetY) / transform.scale;
                
                const newScale = Math.max(0.1, transform.scale * scaleAmount);

                transform.offsetX = centerX - worldX * newScale;
                transform.offsetY = centerY - worldY * newScale;
                transform.scale = newScale;

                initialPinchDistance = currentPinchDistance;
                draw();
            }

            // Botón de reseteo
            resetButton.addEventListener('click', resetView);

            // Controles de zoom
            if (zoomInBtn) {
                zoomInBtn.addEventListener('click', () => {
                    const rect = canvas.getBoundingClientRect();
                    const cx = rect.left + rect.width / 2;
                    const cy = rect.top + rect.height / 2;
                    applyZoom(transform.scale * 1.25, cx - rect.left, cy - rect.top);
                });
            }
            if (zoomOutBtn) {
                zoomOutBtn.addEventListener('click', () => {
                    const rect = canvas.getBoundingClientRect();
                    const cx = rect.left + rect.width / 2;
                    const cy = rect.top + rect.height / 2;
                    applyZoom(transform.scale / 1.25, cx - rect.left, cy - rect.top);
                });
            }
            if (zoom100Btn) {
                zoom100Btn.addEventListener('click', () => {
                    const rect = canvas.getBoundingClientRect();
                    const cx = rect.width / 2;
                    const cy = rect.height / 2;
                    applyZoom(1, cx, cy);
                });
            }
            if (zoomSlider) {
                zoomSlider.addEventListener('input', () => {
                    const rect = canvas.getBoundingClientRect();
                    const cx = rect.width / 2;
                    const cy = rect.height / 2;
                    applyZoom(parseFloat(zoomSlider.value), cx, cy);
                });
            }
            
            // Recalcular la vista si cambia el tamaño de la ventana
            window.addEventListener('resize', resetView);

            // Iniciar la carga de la imagen
            loadImage();
        });
    </script>
</body>
</html>









